<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>four stacks and a half</title>
  
  <subtitle>傻瓜命脉使然</subtitle>
  <link href="/jialugong.github.io/atom.xml" rel="self"/>
  
  <link href="https://jialugong.github.io/jialugong.github.io/"/>
  <updated>2020-01-01T13:10:33.170Z</updated>
  <id>https://jialugong.github.io/jialugong.github.io/</id>
  
  <author>
    <name>GHL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019总结</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2020/01/01/new-year/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2020/01/01/new-year/</id>
    <published>2020-01-01T10:33:44.000Z</published>
    <updated>2020-01-01T13:10:33.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>她第一次感觉到周围的一切都变得陌生，感觉到整个世界都打破了它的界限，展示出可怕的本性，这让她非常不安。　－－《我的天才女友》</p></blockquote><p>算的上是旧的一年的总结了吧，本来打算当做一个技术性blog，奈何自己太菜，能够输出的东西非常少，还不如写一写其它的东西。<br><br>突然发现这一年虽然过得浑浑噩噩，自己最好的年华也不过这几年，但是从某种宽泛的意义上来说，也算是更加深入得探知了这个世界。<br><br>这一年，我才算真正得喜欢上了我的专业，然后还找到了自己以后想做的方向，虽然还很模糊，但是好歹知道了自己该如何去努力争取和努力争取的目标（希望不要向之前那样浮于表面了。<br><br>同时，在这一年也结识了一些有趣的人，让我探知到了世界的广泛与人的多元化，让我对文学、政治等方面有了更多确切的认识，同时还让我看见了人们对于存在意义的不同的见解，看见了不同的人生道路与目标。<br><br>这一年还看了一些书与电影，然而当我回忆我到底看了哪些书与电影的时候，我发现头脑乱成一团线，我竟一时无法分别这到底是我去年看的，还是以前看的。去了豆瓣书店朝圣，还买了一本书《文人论政》。看了今年最令我印象深刻的连续剧《我的天才女友》，虽然对于原作者的一些理念无法苟同。<br><br>写到这，我愈发感觉到语言的贫乏，最近也渐渐能够感受到自己表达能力的丧失。语文该有的起承转合也再不断地消逝，我在慢慢的减轻自己对于世界未知的恐惧，因为我尝试去淡化我对于世事的情感。当我发现我无力改变它的时候，我只能尝试改变我自己。我想到那天中午的对话中，我的内心其实只有一个问题：”你们怎么还能相信能够战胜他们。“我无法分辨谁是谁的枪，他们的目的是什么。<br><br>那些事情让我厌烦，那些轻浮的夸张的虚假的新闻，亦或是那些看似真切的谎言，我希望我能够正直，我希望我能够保持最真切的准则，然而这一切是不可能的，因为那些正确的事情是什么，那些真切的准则是什么，我永远无法探知。<br><br>希望自己2020年能够至少在那些可以找到正确准则的地方探索，同时保持对世界不确定性的尊敬。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;她第一次感觉到周围的一切都变得陌生，感觉到整个世界都打破了它的界限，展示出可怕的本性，这让她非常不安。　－－《我的天才女友》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算的上是旧的一年的总结了吧，本来打算当做一个技术性blog，奈何自己太菜，能够输
      
    
    </summary>
    
    
    
      <category term="others" scheme="https://jialugong.github.io/jialugong.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>关于四叠半</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/12/26/profile/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/12/26/profile/</id>
    <published>2019-12-26T15:00:22.000Z</published>
    <updated>2019-12-26T16:12:05.703Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我已经25岁了，不能再这样下去了。</p></blockquote><p>终于，四叠半的终快要到来了，我仿佛已经听见了片尾曲，以及那些奔跑的声音，而我也终于</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我已经25岁了，不能再这样下去了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;终于，四叠半的终快要到来了，我仿佛已经听见了片尾曲，以及那些奔跑的声音，而我也终于&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>surface-go使用心得</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/12/14/surface/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/12/14/surface/</id>
    <published>2019-12-14T04:41:32.000Z</published>
    <updated>2019-12-14T05:58:30.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：<br>surface go才是真正的生产力工具（震声<br>笔者购买的是surface go 的丐中丐版(因为穷)，4G+64G的配置虽然非常鸡肋，但是这毫不妨碍一些正常功能的使用，使用surface go，你首先得抱着一个卑微的心态，然后才能在探索过程中发现surface go带给你的惊喜。</p></blockquote><h3 id="在surface-上的编程体验"><a href="#在surface-上的编程体验" class="headerlink" title="在surface 上的编程体验"></a>在surface 上的编程体验</h3><h5 id="在surface-go上可以使用的工具"><a href="#在surface-go上可以使用的工具" class="headerlink" title="在surface go上可以使用的工具"></a>在surface go上可以使用的工具</h5><ul><li><input disabled type="checkbox"> pycharm</li><li><input checked disabled type="checkbox"> vscode+node | python | c++</li><li><input disabled type="checkbox"> haroopad</li><li><input checked disabled type="checkbox"> codeblocks</li><li><input checked disabled type="checkbox"> wireshark</li><li><input checked disabled type="checkbox"> postman</li><li><input checked disabled type="checkbox"> anki </li><li><input checked disabled type="checkbox"> xmind<br>…(忘记了,以后补上)<br>当然在surface go上进行绘画、设计什么的就不要想了。sketchbook两个图层都能跑崩…<br>当然最推荐的，也是买surface go的一大原因，就是OneNote啦，而且OneNote跨平台，记录笔记十分的方便，配合OneDrive使用非常香。<h5 id="部分工具截图"><a href="#部分工具截图" class="headerlink" title="部分工具截图"></a>部分工具截图</h5></li><li><strong>One Note</strong><br><img src="http://47.92.141.59/images/blogSurface/oneNote.png" alt="avatar"></li><li><strong>VSCode</strong></li><li><img src="http://47.92.141.59/images/blogSurface/vscode.png" alt="avatar"><h3 id="配置surface-go"><a href="#配置surface-go" class="headerlink" title="配置surface go"></a>配置surface go</h3><blockquote><p>其实也算的是上windows系统的配置啦</p></blockquote></li></ul><p>为了在surface go上取得良好的编程体验,我大概做了以下的一些工作（后期可能会整理一下具体的流程）</p><ul><li>安装fluent terminal并进行美化</li><li>安装chocolatey用于windows下的软件包的管理</li><li>安装git</li><li>安装nvm进行node的版本管理</li><li>安装gow，可以在windows上运行一些linux上的命令行（如：grep、tar、which等）<br>总之，最终效果如下（仅有fluent terminal），等到考试结束想装一下WSL，看一下效果（但是感觉装了也不会用）<br><img src="http://47.92.141.59/images/blogSurface/fluent.png" alt="avatar"><h3 id="将surface-go变为主力机的扩展屏"><a href="#将surface-go变为主力机的扩展屏" class="headerlink" title="将surface go变为主力机的扩展屏"></a>将surface go变为主力机的扩展屏</h3>这是win 10上非常棒的一点。因为没钱买屏幕，笔者之前在前端调试时只能用分屏，调试过程十分痛苦，但是自从配合surface go使用了这个功能后，腰不痛了，腿不麻了，写bug的速度都加快了。整个过程十分简单，主要的步骤如下：<blockquote><p>surface go设置</p></blockquote></li></ul><p><img src="http://47.92.141.59/images/blogSurface/screenSurface.png" alt="avatar"></p><blockquote><p>主力机：就点击 投影-&gt;扩展-&gt;连接到无线显示屏（之前两个电脑要先蓝牙链接）</p></blockquote><p><img src="http://47.92.141.59/images/blogSurface/screenFinal.jpg" alt="avatar"><br>最终效果如下（请忽略背景）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：&lt;br&gt;surface go才是真正的生产力工具（震声&lt;br&gt;笔者购买的是surface go 的丐中丐版(因为穷)，4G+64G的配置虽然非常鸡肋，但是这毫不妨碍一些正常功能的使用，使用surface go，你首先得抱着一个卑微的心态，然后
      
    
    </summary>
    
    
    
      <category term="surface-go 其它" scheme="https://jialugong.github.io/jialugong.github.io/tags/surface-go-%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>restful的实践</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/11/02/axois%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/11/02/axois%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-11-02T02:06:01.000Z</published>
    <updated>2019-12-26T15:35:37.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前记：为什么写下这篇文章？主要是想实践一下关于<a href="https://developer.github.com/v3/#json-p-callbacks" target="_blank" rel="noopener">restful api</a>的理念，在此前的web项目中，一直只采用get | post两种方式，并且对于api的命名十分不规范，这可能导致api接口十分的庞杂且紊乱，小项目还好，大项目可能就十分令人头大（虽然也没做过什么大项目）。于是我选择用<a href="http://www.axios-js.com/docs/" target="_blank" rel="noopener">axios</a>来实现本次的实践。为什么axios？（<del>当然是因为尤大的推荐了</del>），axios是使用promise进行异步管理，就告别了以前的回调函数可能出现的代码可读性差的问题。此外，axios还支持拦截器等功能。</p></blockquote><p>[TOC]</p><ul><li><h4 id="restful-api"><a href="#restful-api" class="headerlink" title="restful api"></a>restful api</h4><p>  google 上对于restful api的介绍大概是这样：A RESTful API is an application program interface (API) that uses HTTP requests to GET, PUT, POST and DELETE data.看过相关文章，其中一篇饿了么前端写的关于restful　api的文章很好地解释了Restful api到底是一个什么东西。<br>  <strong>它的特点有两个:</strong></p><ul><li>api的url只是用来表示资源，由此不能用动词命名，并且应该区分好是复数还是单数</li><li>用Method来表示对于资源的操作<br>因此一个良好的api的url是：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/api/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h4><p>假设存在这样一个API:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">url:</span><span class="meta-keyword">/api/</span>user/<span class="number">123</span></span><br></pre></td></tr></table></figure></li></ul><p>它所表示的资源是一个json包，并且数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>methods</th><th>GET</th><th>POST</th><th>PUT</th><th>PATCH</th><th>DELETE</th></tr></thead><tbody><tr><td>dscription</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>备注</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>返回的结果</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>- #### 情景分析(重构library admin部分)</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前记：为什么写下这篇文章？主要是想实践一下关于&lt;a href=&quot;https://developer.github.com/v3/#json-p-callbacks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;restful ap
      
    
    </summary>
    
    
    
      <category term="restful" scheme="https://jialugong.github.io/jialugong.github.io/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>安装zsh中遇到的问题</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/10/15/zsh/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/10/15/zsh/</id>
    <published>2019-10-15T12:37:05.000Z</published>
    <updated>2019-12-26T14:32:04.121Z</updated>
    
    <content type="html"><![CDATA[<p>在使用zsh中，大概率会遇到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh：command not found:xxx</span><br></pre></td></tr></table></figure><p>的问题。当然我也遇到了（呜呜<del>(&gt;_&lt;)</del>），作为一个小白，也不知道该怎么解决，也只能上网搜一搜，然而，网上给出的解决方法一根本不能解决问题（具体请看blog）。小白就是小白，只能用各种暴力方法解决问题了，于是想到了第二种解决办法。</p><ul><li><p>解决方法一</p><ul><li><p>打开~.zshrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .zshrc</span><br></pre></td></tr></table></figure></li><li><p>添加一行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~.bash_profile</span><br></pre></td></tr></table></figure></li></ul></li><li><p>解决方法二<br>由于笔者没有.bash_profile这一文件，但是网上搜索到的诸多教程都是解决方法一。看过几篇文章后突然想到我将nvm、node等环境配置全部写在了bashrc里边，然后就试着运行了一下‘source .bashrc’,结果报了一大堆错误。突然想到，我用的是zsh，bash当然会报错（卒）。<br>所以，解决方法二，就是将.bashrc中关于node的配置copy到.zshrc里边。然后再</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~.zshrc</span><br></pre></td></tr></table></figure></li></ul><p>问题就解决了。<br>就以node举栗(笔者使用nvm管理的node)：<br>将.bashrc中的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR="$HOME/.nvm"</span><br><span class="line">[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh"  # This loads nvm</span><br><span class="line">[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure><p>copy到~.zshrc下就可以啦。</p><p>参考文章：<br><a href="[https://blog.csdn.net/lxn9492878lbl/article/details/80795413](https://blog.csdn.net/lxn9492878lbl/article/details/80795413">ubuntu 安装zsh终端</a><br><a href="[https://blog.csdn.net/u010954988/article/details/80404329](https://blog.csdn.net/u010954988/article/details/80404329">zsh:command not found</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用zsh中，大概率会遇到&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
      
    
    </summary>
    
    
    
      <category term="oh-my-zsh" scheme="https://jialugong.github.io/jialugong.github.io/tags/oh-my-zsh/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的新特性</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/10/10/ES5%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/10/10/ES5%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2019-10-09T16:05:33.000Z</published>
    <updated>2019-10-13T04:32:24.264Z</updated>
    
    <content type="html"><![CDATA[<p>吐槽：呜呜呜～，之前忘记保存了，更新速度可能会变慢</p><blockquote><p>写在之前 ：此文为个人的翻译+粗暴理解，<a href="https://babeljs.io/docs/en/learn" target="_blank" rel="noopener">原文</a></p></blockquote><ul><li>#####箭头函数与this语法<br>大体上，箭头函数可以作为function的替代，但是有一点不同.箭头函数能和他周围的代码一样，共享this语法，如果一个箭头函数在另一个函数中，箭头函数能够共享其父函数的参数变量<br>示例代码：<blockquote><p>共享this语法</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bob = &#123;</span><br><span class="line">    _name: <span class="string">"Bob"</span>,</span><br><span class="line">    _friends: [],</span><br><span class="line">    printFriends() &#123;</span><br><span class="line">      <span class="keyword">this</span>._friends.forEach(<span class="function"><span class="params">f</span> =&gt;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>._name + <span class="string">" knows "</span> + f));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  bob._friends=[<span class="string">'Alice'</span>,<span class="string">'Ann'</span>,<span class="string">'Tom'</span>]</span><br><span class="line">  bob.printFriends()</span><br></pre></td></tr></table></figure><blockquote><p>调用父函数的参数变量</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> compute = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = []</span><br><span class="line">    <span class="keyword">for</span> (number <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">      numbers.push(number*number)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> compute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> ]</span><br></pre></td></tr></table></figure><blockquote><p>若箭头函数内为表达式（expression body），可隐式返回结果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(callback(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y)</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><ul><li>#####类<br>ES5中的类是一个基于原型OO模式的语法糖.简单单一的申明使得类模式的使用更加简单。类支持基于原型的继承，超级调用，实例以及静态方法和构造函数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;吐槽：呜呜呜～，之前忘记保存了，更新速度可能会变慢&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写在之前 ：此文为个人的翻译+粗暴理解，&lt;a href=&quot;https://babeljs.io/docs/en/learn&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://jialugong.github.io/jialugong.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>js中的异步</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/09/30/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/09/30/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/</id>
    <published>2019-09-30T11:20:36.000Z</published>
    <updated>2019-10-13T04:32:51.526Z</updated>
    
    <content type="html"><![CDATA[<p>####写在之前<br>笔者是前端初学者，本文主要是对于javascript中异步一个简单的介绍以及列举一些简单的例子，对于js异步的理解，我也是刚刚入门，写这篇文章的目的仅仅是为了记录目前所掌握到的知识<br>####正文</p><ul><li><h6 id="ES6中的Promise对象"><a href="#ES6中的Promise对象" class="headerlink" title="ES6中的Promise对象"></a>ES6中的Promise对象</h6></li><li><h6 id="异步函数的使用方式"><a href="#异步函数的使用方式" class="headerlink" title="异步函数的使用方式"></a>异步函数的使用方式</h6></li><li><h6 id="为什么使用异步函数"><a href="#为什么使用异步函数" class="headerlink" title="为什么使用异步函数"></a>为什么使用异步函数</h6></li></ul><h5 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h5><p>要了解异步，首先应该了解js中的promise对象，因为我们知道，async函数返回的是一个promise对象，我们可以通过以下代码知道</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">x=test();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123; <span class="string">'hello'</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在编写js时，我们总是不可避免地使用到各种回调函数，而Promise就是把基于回调函数的异步处理对象和处理规则进行规范化，并按照统一的接口来编写(引自<a href="http://liubin.org/promises-book/#introduction" target="_blank" rel="noopener">promise的迷你书</a>)</p></blockquote><ul><li>Promise的三种状态<ul><li>Pending</li><li>Resovled</li><li>Rejected</li></ul></li></ul><pre class="mermaid">graph LRPending-->ResolvedPending-->Rejected</pre><blockquote><p>一个Promise实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">10</span>)</span><br><span class="line">            resolve(<span class="string">"hello world!"</span>)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            reject(<span class="string">"something wrong!"</span>)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notAsyncFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I'm the second but I come first"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunction(a).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">notAsyncFunction();</span><br></pre></td></tr></table></figure><p>输入输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;a=<span class="number">8</span></span><br><span class="line">&gt;&gt;I<span class="string">'m the second but I come first</span></span><br><span class="line"><span class="string">  something wrong!</span></span><br><span class="line"><span class="string">&gt;&gt;a=20</span></span><br><span class="line"><span class="string">&gt;&gt;I'</span>m the second but I come first</span><br><span class="line">  hello world!</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以发现：</p><ul><li>异步函数不会阻塞代码的执行</li><li>Promise最终的返回状态有两种即resolved和rejected</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####写在之前&lt;br&gt;笔者是前端初学者，本文主要是对于javascript中异步一个简单的介绍以及列举一些简单的例子，对于js异步的理解，我也是刚刚入门，写这篇文章的目的仅仅是为了记录目前所掌握到的知识&lt;br&gt;####正文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h6 id=&quot;ES6
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://jialugong.github.io/jialugong.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>一个吐槽</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/09/02/bbb/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/09/02/bbb/</id>
    <published>2019-09-02T11:58:29.000Z</published>
    <updated>2019-10-13T04:32:38.981Z</updated>
    
    <content type="html"><![CDATA[<p>感觉可以做一个<del>踩坑</del>(吐槽)集合了</p><ul><li>一个困扰了一天的bug,严重地放慢了整个项目的进度.原因是这样的,同学用windows系统做开发,我是用linux系统做开发,然后她将一个eclipse下写的javaweb项目发给我后,我在linux下运行.maven build成功,tomcat的端口也是打开的,结果,结果,<strong>404</strong>,<strong>404</strong>,折腾了一天,开始还以为是maven仓库的问题,就各种倒腾环境,大概浪费了一天的时间,终于在今天,发现是编码问题,<strong>编码</strong>问题,因为windows是GBK编码,而linux是UTF-8编码,我发现这个可能是原因还是因为同学写的一个中文注释在我这边是乱码,然后抱着侥幸心里修了一下,结果就成功了.然而这是有多玄学,之前就没改编码就能运行,然而昨天就不行。<ul><li>教训：在协作开发之前，无论是编程环境、接口数据类型还是编码、换行符等事宜，一定得先确定好，有一个规范与标准（泪的教训）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感觉可以做一个&lt;del&gt;踩坑&lt;/del&gt;(吐槽)集合了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个困扰了一天的bug,严重地放慢了整个项目的进度.原因是这样的,同学用windows系统做开发,我是用linux系统做开发,然后她将一个eclipse下写的javaweb项目发给我后,我在l
      
    
    </summary>
    
    
      <category term="java web" scheme="https://jialugong.github.io/jialugong.github.io/categories/java-web/"/>
    
    
  </entry>
  
  <entry>
    <title>python在多维线性回归中的应用</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/05/03/python1/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/05/03/python1/</id>
    <published>2019-05-03T00:06:16.000Z</published>
    <updated>2019-05-10T02:05:31.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在文章之前:这次是参加学校数模比赛,用到了线性回归模型来拟合三维散点图,由此得到几个因素之间的关系.建议配合R一起使用.</p></blockquote><p>#TODO LIST</p><ul><li>完善代码注释与函数的扩展</li><li>贴出结果图</li><li>对于summray结果的分析</li><li>对于线性回归模型的扩展</li></ul><hr><ul><li><p>##关于多元线性回归<br>探究三者</p></li><li><p>##代码部分<br><strong>python代码:</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#数据</span></span><br><span class="line">xx=(<span class="number">112</span>,<span class="number">371</span>,<span class="number">318</span>,<span class="number">445</span>,<span class="number">185</span>,<span class="number">510</span>)</span><br><span class="line">yy=(<span class="number">10452</span>,<span class="number">8617</span>,<span class="number">11089</span>,<span class="number">9169</span>,<span class="number">11388</span>,<span class="number">9308</span>)</span><br><span class="line">zz=(<span class="number">898</span>,<span class="number">741</span>,<span class="number">1686</span>,<span class="number">1024</span>,<span class="number">1408</span>,<span class="number">1113</span>)</span><br><span class="line"></span><br><span class="line">X,Z=np.column_stack((xx,yy)),zz</span><br><span class="line">regr=linear_model.LinearRegression()</span><br><span class="line">regr.fit(X,Z)</span><br><span class="line"><span class="comment">#得到平面的系数和截距</span></span><br><span class="line">a,b=regr.coef_,regr.intercept_</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出散点图</span></span><br><span class="line">fig=plt.figure()</span><br><span class="line">ax=fig.gca(projection=<span class="string">'3d'</span>)</span><br><span class="line">xxx=np.linspace(<span class="number">1</span>,<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line">yyy=np.linspace(<span class="number">7000</span>,<span class="number">12000</span>,<span class="number">10</span>)</span><br><span class="line">XXX,YYY=np.meshgrid(xxx,yyy)</span><br><span class="line">XX=np.column_stack((XXX.flatten(),YYY.flatten()))</span><br><span class="line"></span><br><span class="line">ax.scatter(xx,yy,zz,c=<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出拟合的平面</span></span><br><span class="line">ax.plot_wireframe(XXX,YYY,regr.predict(XX).reshape(<span class="number">10</span>,<span class="number">10</span>),alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.plot_surface(XXX,YYY,regr.predict(XX).reshape(<span class="number">10</span>,<span class="number">10</span>),alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>###结果如图:<br><img src="/jialugong.github.io/2019/05/03/python1/Figure_1.png" alt></p><p><strong>用R中的函数,能够得到对于该模型的检验和评价</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据</span></span><br><span class="line">x&lt;-c(<span class="number">112</span>,<span class="number">371</span>,<span class="number">318</span>,<span class="number">445</span>,<span class="number">185</span>,<span class="number">510</span>)</span><br><span class="line">y&lt;-c(<span class="number">10452</span>,<span class="number">8617</span>,<span class="number">11089</span>,<span class="number">9169</span>,<span class="number">11388</span>,<span class="number">9308</span>)</span><br><span class="line">z&lt;-c(<span class="number">898</span>,<span class="number">741</span>,<span class="number">1686</span>,<span class="number">1024</span>,<span class="number">1408</span>,<span class="number">1113</span>)</span><br><span class="line"><span class="comment">#进行多元线性分析</span></span><br><span class="line">lm.result&lt;-lm(z~x+y)</span><br><span class="line"><span class="comment">#拟合情况分析</span></span><br><span class="line">summary(lm.result)</span><br><span class="line"><span class="comment">#残差分析(Q-Q图)</span></span><br><span class="line">qqnorm(lm.result)</span><br></pre></td></tr></table></figure><p><strong>结果分析如下:</strong><br><img src="/jialugong.github.io/2019/05/03/python1/huigui_fenxi.png" alt></p><ul><li>call:<br>是对于所用的现行回归函数的再现</li><li>Residuals<br>一般会显示所得残差的最大值(max),,中位数他<br>但因为此处我们所用的值太少,故R将所有的残差都显示了出来</li><li>Coefficients</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写在文章之前:这次是参加学校数模比赛,用到了线性回归模型来拟合三维散点图,由此得到几个因素之间的关系.建议配合R一起使用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#TODO LIST&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完善代码注释与函数的扩展&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="python可视化" scheme="https://jialugong.github.io/jialugong.github.io/categories/python%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>实分析学习</title>
    <link href="https://jialugong.github.io/jialugong.github.io/2019/04/24/math/"/>
    <id>https://jialugong.github.io/jialugong.github.io/2019/04/24/math/</id>
    <published>2019-04-24T06:20:56.534Z</published>
    <updated>2019-04-26T03:40:18.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这只是一个测试,来测试现在是否支持mathjax.</p></blockquote><h2 id="关于自然数的定义"><a href="#关于自然数的定义" class="headerlink" title="关于自然数的定义"></a>关于自然数的定义</h2><h5 id="运用Peano公理定义自然数"><a href="#运用Peano公理定义自然数" class="headerlink" title="运用Peano公理定义自然数"></a>运用<strong>Peano</strong>公理定义自然数</h5><ul><li><strong>peano</strong>公理的定义:<blockquote><ul><li><strong>公理一</strong>:<br>0是自然数</li><li><strong>公理二</strong>:<br>若$n$是自然数,则$n++$也是自然数.</li><li><strong>公理三</strong><br>0不是任何自然数的后继.</li><li><strong>公理四</strong><br>不同自然数的后继不相同,即,设$m$,$n$是自然数,若$m \neq n$,则$m++ \neq n++$,等价来说(运用逆否命题),若$m++ = n++$,则必有$m=n$.</li><li><strong>公理五</strong>(运用数学归纳原理)<br>设$P(n)$是关于自然数的一个性质,假设$P(0)$是真的,并假设只要$P(n)$是真的,则$P(n++)$是真的,那么对于每个自然数$P(n)$都是真的.</li></ul></blockquote></li></ul><p><em>(一个有趣的点:自然数系$\mathbb{N}$是无限的,然而它个体是有限的,整体大于局部,$\infty$不属于自然数&lt;-(根据公里五的定义,若0是有限的,则自然数系里的每一个数都是有限的))</em></p><ul><li>命题(递归定义)<br>设对于每个自然数$n$,都有某个函数$f^{}_{n}:\mathbb { N }$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这只是一个测试,来测试现在是否支持mathjax.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于自然数的定义&quot;&gt;&lt;a href=&quot;#关于自然数的定义&quot; class=&quot;headerlink&quot; title=&quot;关于自然数的定义&quot;&gt;&lt;/a&gt;关于
      
    
    </summary>
    
    
      <category term="math" scheme="https://jialugong.github.io/jialugong.github.io/categories/math/"/>
    
    
  </entry>
  
</feed>
